# vite 的预加载

```js
import _ from "lodash";
```

在处理过程中如果说看到了有 非绝对路径或者相对路径的引用，他则会尝试开启路径补全

```js
import _ from "/node_modules/.vite/deps/lodash.js?v=d927b29c";
```

找寻依赖的过程是自当前目录一次向上查找的过程，直到搜寻到根目录或者搜寻到依赖为止 /user/node_modules/lodash, ../

区分 生产和开发
yarn dev ---> 开发（每次依赖于构建所重新构建的相对路径都是正确的）

生产：vite 会全权交给一个叫做 rollup 的库去完成生产环境的打包

缓存 --->

实际上 vite 在考虑另一个问题的时候就顺便把这个问题解决了

commonjs 规范的导出 module.exports

有的包他是以 commonjs 规范的格式导出 比如 axios

**依赖预构建**：首先 vite 会找到对应的依赖，然后调用 esbuild（对 js 语法进行处理的一个库），将其他规范的代码转换成 esmodule 规范，然后放到当前目录下的 node_modules/.vite/deps，同时对 esmodule 规范的各个模块进行统一集成(yarn add lodash-es -S)

```js
// a.js
export default function a() {}
```

```js
export { default as a } from "./a.js";
// 相当于
import a from "./a.js";
export const a = a;
```

vite 重写以后,直接把它（export {default as a} from "./a.js"）不要了

```js
function a() {}
```

他解决了 3 个问题：
1、不同的第三方包会有不同的导出格式（这个是 vite 没法约束人家的事）
2、对路径的处理上可以直接使用.vite/deps，方便路径重写
3、叫做网络多包传输的性能问题（也是原生 esmodule 规范不敢支持 node_modules 的原因之一），有了依赖预构建以后，无论他有多少额外的 export 和 import,vite 都会尽可能的将他们进行集成，最后只生成一个或者几个模块

vite.config.ts === webpack.config.ts

